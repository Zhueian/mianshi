                        分布式事务：
1：2PC理论
    1。分布式事务的目标：解决多个独立事务一致性的问题。 分布式场景下没有事务，只有数据原子性问题
        eg：一个业务跨越多个微服务，每个微服务对应独立的库。

    2.二阶段提交协议
        给予XA协议的强一致性ACID
        2pc ：基于XA/JTA规范

    3。简单的说就是
        3.1。投票：各个独立事务执行sql但不提交，把执行结果 success/failed 发送个分布式协调者
        3.2。提交：最后所有sql执行结果求并，一起提交或回滚

    4。缺点：单点故障，独立事务同一条数据的的同步阻塞（行级锁），数据不一致（网络问题超时 有的独立事务提交了有的没）
        不过俩阶段的请求响应都是毫秒级别 成功率都是99。98% 这个俩阶段方案能解决很多场景问题了

    5。三阶段：加了预提交和超时机制，只是提高了所有事务提交的成功概率，没完全解决问题

2：BASE理论
    1。BASE 消息一致性方案 eBay架构师提出的
    2。定时任务扫表补偿 或者人工客服补偿（开发的锅甩给运营）

    3。网约车以前做法：本地事务+定时任务+消息队列+事件表 ； 消息队列柔性事务

3：TCC理论
    1。TCC try confirm cancel 实现这个事务需要三个api
        a预先占有资源 b确认提交实际操作 c取消占有
        如果后俩个环节执行失败一半了，log 人工补偿

    2。也不咋用，特别繁琐

    3。2pc 回跨多个db 都锁了，耗资源 ； TCC 不回一直持有锁，锁粒度小，每操作一个锁一个放一个。高并发下tcc好点。

4：seata框架，有点想apollo 这种框架要引入xxx-server和对应的数据库表。
    1。@GobaleTranctional（rockbackFor = Exception.class）业务0侵入 部署个seata-server+db

b站cap 简单明了说明：C（consistency）一致性、P(partition tolerance) 分区容错性、A(availability) 可用性
                  cp或者ap 分布式一定要有p，没p单机的话也就没有这么多事了。